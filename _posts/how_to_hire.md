# 如何招聘的



## 搞清楚为什么需要招人

首先我们需要清楚公司招人的目的是什么。公司招人的目的是进行有规模的商业化，而招工程师的目的则是：用有限的成本（人力、时间）用满足要求的人通过软件工程创造出一定质量的东西来服务商业活动。而软件工程是一个多维度的、复杂的过程，参与其中的人起到了至关重要的作用。






## 我们需要什么样的人


要回答我们需要招什么人，首先我们需要清楚公司招人的目的是什么。公司招人的目的是进行有规模的商业化，而招工程师的目的则是：用有限的成本（人力、时间）用满足要求的人创造出一定质量的东西来服务商业活动。软件工程是一个多维度的、复杂的过程。

HR 说我们需要：能干活的，ACMer 说我们需要：算法好的，牛人说我们需要：更强的牛人，清北的说我们需要：聪明的。


然而在软件工程中，代码实现只是其中的一个部分，而算法更只是代码实现的其中一个部分。

不同阶段商业活动对软件工程的需求是不一样的，这样意味着不同阶段我们所需要的人是不一样的，如果真要得出有一个结论那么我认为是**合适的人**



技术层面

非技术层面


> 能力基础，不要幻想你能培养出能力，一个人的综合素质是基础，是几十年培养出来的东西，不是几个月一两年能够培养出来的。


> 通过经年累月的时间，家长对塑造孩子可以施加影响， 而个人对自己也可能做出巨大的改变。然而，管理者却不可能从本质上改变他们的员工。人们通常在短时间内很难做出改变，管理者也很难找到杠杆的支点来撬动他们发生本质的改变。所以，
在为你工作期间，人们在离开时和刚进来时并没有什么区别。一 开始不适合工作的人，那就永远都不适合。
这意味着从一开始就找到正确的人至关重要。


## 如何获取简历

一线的大厂的


## 简历评估


**细节很重要**

在没有和候选人没有过其他沟通以及面试的情况，简历是我们获取候选人信息最重要的途径。因此我们会对简历内容有更多的关注。

简历是求职的敲门砖，很难想象如果一个人对一件简单而对自己很重要的事情都马马虎虎，在工作上怎么让人放心呢？特别是当候选人还是一个已经工作多年的工程师的时候。因此在简历细节上应该尽量做到无可挑剔。

这些细节包括没有明显的错别字、没有写错编程语言的名称等等，有一些求职邮件就只有一个附件，邮件也没有什么正文，甚至连申请什么职位也没写，给人的感觉就是此人懒到了极点，连求职都这样，可见其他事情也会很马虎。

**有亮点**


**工作经历匹配度**


## 如何面试

关于如何面试可以可以看[我们是如何进行技术面试的](./interview.md)



## 招聘是主管的职责


## 


### Independence and autonomy


Developers want to be hired for their skills, and treated as experts, and allowed to make decisions within their own realm of expertise.

All in all, focusing on the social dynamics of your organization is crucial to making a healthy, pleasant place to work that will retain programmers and attract programmers.



High tech teams have many goals but making everyone happy is rarely goal number one.



Robert Austin, in his book Measuring and Managing Performance in Organizations, says there are two phases when you introduce new performance metrics. At first, you actually get what you wanted, because nobody has figured out how to cheat. In the second phase, you actually get something worse, as everyone figures out the trick to maximizing the thing that you’re measuring, even at the cost of ruining the company.

Worse, Econ 101 managers think that they can somehow avoid this situation just by tweaking the metrics. Dr. Austin’s conclusion is that you just can’t. It never works. No matter how much you try to adjust the metrics to reflect what you think you want, it always backfires.

 management is just an annoying, mundane chore someone has to do so that the smart people can get their work done.Managers exist to get furniture out of the way so the real talent can do brilliant work.

 If there’s one thing I know, it’s that managers have the least information about every technical issue, and they are the last people who should be deciding anything. 




 I knew one thing: programmers who start businesses often have the bad habit of thinking everybody else is a programmer just like them and wants the same stuff as them, and so they have an unhealthy tendency to start businesses that sell programming tools. That’s why you see so many scrawny companies hawking source-code-generating geegaws, error catching and emailing geegaws, debugging geegaws, syntax-coloring editing tchotchkes, ftping baubles, and, ahem, bug tracking packages. All kinds of stuff that only a programmer could love.


 Almost every tech support problem has two solutions. The superficial and immediate solution is just to solve the customer’s problem. But when you think a little harder you can usually find a deeper solution: a way to prevent this particular problem from ever happening again.



## 最后的期限

优秀管理的四大要素：
- 选择正确的人
- 为他们分配正确的工作
- 保持他们的积极性
- 帮助团队凝聚起来并保持团队的凝聚力
其他的一起都只是“文案”


在所有成功的工程中，变化都是基本的要素之一。
逃避风险是致命的，因为这会让你也得不到与风险同存的利益。


没有“短期生产力提高”这样的东西，生产力的提高是来自长期投资的。

在项目进行的过程中，不要希望在超过一个方法范围内实施改进。多个方向的改进很可能让项目比不实施这些程序完成得更晚。

如果你不关心别人，不照顾别人，就别想让他们为你做一些不同寻常的事情。

压力下的人不能更快地思考。
我们都站在同一边，跟我们对立的，是我们要解决的问题。




## Facts

The most important factor in software work is not the tools and techniques used by the programmers,
but rather the quality of the programmers themselves.

The major problems of our work are not so much
technological as sociological in nature

The prime factor in affecting the reliability of software is in the selection,
motivation, and management of the personnel who design and maintain it




The most important factor in software work is not the tools and techniques used by the programmers,
but rather the quality of the programmers themselves


The best programmers are up to 28 times better than the worst programmers, according to "individual
differences" research. Given that their pay is never commensurate, they are the biggest bargains in the
software field.


Adding people to a late project makes it later.

The working environment has a profound impact on productivity and product quality.

Hype is the plague on the house of software.


Learning a new tool or technique actually lowers programmer productivity and product quality
initially. The eventual benefit is achieved only after this learning curve is overcome. Therefore, it is
worth adopting new tools and techniques, but only (a) if their value is seen realistically and (b) if
patience is used in measuring benefits.


Software developers talk a lot about tools. They evaluate quite a few, buy a fair number, and use
practically none.


One of the two most common causes of runaway projects is poor estimation.


Most software estimates are performed at the beginning of the life cycle. This makes sense until we
realize that estimates are obtained before the requirements are defined and thus before the problem is
understood. Estimation, therefore, usually occurs at the wrong time.


Most software estimates are made either by upper management or by marketing, not by the people
who will build the software or their managers. Estimation is, therefore, done by the wrong people.


Software estimates are rarely adjusted as the project proceeds. Thus those estimates done at the wrong
time by the wrong people are usually not corrected.


Since estimates are so faulty, there is little reason to be concerned when software projects do not meet
estimated targets. But everyone is concerned anyway.


There is a disconnect between management and their programmers. In one research study of a project
that failed to meet its estimates and was seen by its management as a failure, the technical participants
saw it as the most successful project they had ever worked on.


The answer to a feasibility study is almost always "yes."

Reuse-in-the-small (libraries of subroutines) began nearly 50 years ago and is a well-solved problem.

Reuse-in-the-large (components) remains a mostly unsolved problem, even though everyone agrees it
is important and desirable.

Reuse-in-the-large works best in families of related systems and thus is domain-dependent. This
narrows the potential applicability of reuse-in-the-large.


Modification of reused code is particularly error-prone. If more than 20 to 25 percent of a component
is to be revised, it is more efficient and effective to rewrite it from scratch.It is almost always a mistake to modify packaged, vendor-produced software systems.


Eighty percent of software work is intellectual. A fair amount of it is creative. Little of it is clerical.


When moving from requirements to design, there is an explosion of "derived requirements" (the requirements for a particular design solution) caused by the complexity of the solution process. The list of these design requirements is often 50 times longer than the list of original requirements.


There is seldom one best design solution to a software problem.


Design is a complex, iterative process. The initial design solution will likely be wrong and certainly
not optimal.

Error removal is the most time-consuming phase of the life cycle.


Software that a typical programmer believes to be thoroughly tested has often had only about 55 to 60
percent of its logic paths executed. Using automated support, such as coverage analyzers, can raise
that roughly to 85 to 90 percent. It is nearly impossible to test software at the level of 100 percent of
its logic paths.

Test automation rarely is. That is, certain testing processes can and should be automated. But there is a
lot of the testing activity that cannot be automated.


Rigorous inspections can remove up to 90 percent of errors from a software product before the first
test case is run.

In spite of the benefits of rigorous inspections, they cannot and should not replace testing.

Maintenance typically consumes 40 to 80 percent (average, 60 percent) of software costs. Therefore, it
is probably the most important life cycle phase of software.

Maintenance is a solution, not a problem.


Quality in the software field is about a collection of seven attributes that a quality software product
should have: portability, reliability, efficiency, usability (human engineering), testability,
understandability, and modifiability. Various software people provide somewhat different sets of
names for those attributes, but this list is pretty generally accepted and has been for almost 30-
something years.Quality is not user satisfaction, meeting requirements, meeting cost and schedule targets, or reliability.


There is no single best approach to software error removal.Residual errors will always persist. The goal should be to minimize or eliminate severe errors.

Efficiency stems more from good design than from good coding.

You can't manage what you can't measure.




人与人之间的交五是复杂的，并且其效来从来都难以额期，但却是工作中最为重要的方面。

教堂火顶上的风标，即使由钢铁制成，如果不懂得顺应风势的芒术，一样会被暴风立即摧毁。