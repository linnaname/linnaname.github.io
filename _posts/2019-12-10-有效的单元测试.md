---
layout:     post
title:      读书笔记-有效的单元测试
subtitle:   有效的单元测试
date:       2019-12-10
author:     Lnn
header-img: img/home-bg-art.jpg
catalog: 	 true
tags:
    - 读书笔记
    - 单元测试
---

### 优秀测试的替身
![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586853830700-56244d87-d2f5-45b9-923e-4dea82faf0d6.png#align=left&display=inline&height=361&margin=%5Bobject%20Object%5D&name=image.png&originHeight=361&originWidth=204&size=85668&status=done&style=none&width=204)

100%测试覆盖率不是目标<br />争议在于：写多少测试？写哪种测试？<br />双稳态定律：编写测试的最大价值不在于结果，而在于编程过程中的学习。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586854006419-cfef9d94-b368-4231-97da-3fac8a9712f4.png#align=left&display=inline&height=349&margin=%5Bobject%20Object%5D&name=image.png&originHeight=349&originWidth=235&size=93825&status=done&style=none&width=235)

<a name="9A2pm"></a>
#### 影响生产力的因素
**<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586854256091-57f87422-aa57-4142-a707-1bd473fe831a.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=375&originWidth=574&size=242344&status=done&style=none&width=574)


<a name="bbGgT"></a>
#### 测试作为设计工具
![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586867552683-f0aa56de-6b9a-49ae-89a1-8b30c4a5ae86.png#align=left&display=inline&height=93&margin=%5Bobject%20Object%5D&name=image.png&originHeight=93&originWidth=397&size=37418&status=done&style=none&width=397)

TDD的好处：<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586867526999-13516bbd-6281-4bec-b7b8-0ec26cdb00f0.png#align=left&display=inline&height=53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=53&originWidth=396&size=25755&status=done&style=none&width=396)

偶发复杂性


<a name="jpo18"></a>
### 寻求优秀

可读的代码才是可维护的代码<br />结构有助于理解事物<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586870689286-a1d60f83-646c-4fa8-924c-e156ef698b45.png#align=left&display=inline&height=199&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=440&size=98177&status=done&style=none&width=440)

测试应易于单独运行，而不要有前后顺序的依赖。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586911840625-3208ba5a-a137-4182-95e8-9b3e6c83d216.png#align=left&display=inline&height=212&margin=%5Bobject%20Object%5D&name=image.png&originHeight=212&originWidth=574&size=128721&status=done&style=none&width=574)<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586871332322-2cb44c78-ada3-4ad3-84cb-fb4833695d97.png#align=left&display=inline&height=268&margin=%5Bobject%20Object%5D&name=image.png&originHeight=268&originWidth=609&size=193306&status=done&style=none&width=609)

可靠的测试才是可靠的，几乎不会失败的测试就是无用的废物，也就是说，间歇性的通过或者失败的测试就是在公然的侵害工程师的生产力。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586871492357-1ca28d27-33a5-4a04-ab48-e1bd4775c612.png#align=left&display=inline&height=133&margin=%5Bobject%20Object%5D&name=image.png&originHeight=133&originWidth=413&size=63298&status=done&style=none&width=413)

测试替身：测试工具、集成工具等/stub、fake、mock<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586871756416-926e3384-8ac5-4a2d-9c1b-d89e0c539809.png#align=left&display=inline&height=70&margin=%5Bobject%20Object%5D&name=image.png&originHeight=70&originWidth=569&size=48028&status=done&style=none&width=569)
<a name="da1V0"></a>
### 测试替身

好处：隔离被测代码、加速执行测试、让测试变得确定<br />类型：<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586912121492-dd0605ef-3727-4bff-9e52-07f887a32b6d.png#align=left&display=inline&height=138&margin=%5Bobject%20Object%5D&name=image.png&originHeight=138&originWidth=403&size=62264&status=done&style=none&width=403)

指南：<br />1.stub管查询，mock管操作<br />2.准备-执行-断言


<a name="sHPRs"></a>
### 可读性
1.基本断言<br />2.过度断言<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1586917536263-914a1247-56c2-4b95-94db-c6194256c447.png#align=left&display=inline&height=79&margin=%5Bobject%20Object%5D&name=image.png&originHeight=79&originWidth=573&size=52597&status=done&style=none&width=573)<br />3.用一个或者多个布尔运算来替换位运算<br />4.测试的每个方法应该尽量在同一个抽象层次内，比如把setup或者init内容放在before或者单独的方法中。<br />5.一个测试应当只检查一件事并妥善执行，分块心理学<br />6.用具有表现力名字的本地变量或者倡廉替换魔法数字。<br />7.将冗长的安装抽取无关细节，放入私有方法中


<a name="67RX4"></a>
### 可维护性
1.消除重复：结构重复、语义重复<br />2.文件路径可迁移<br />3.删除建立的临时文件<br />4.适当使用并发工具加快测试速度<br />5.用参数化工具简化代码和逻辑


<a name="EKuFw"></a>
### 可信赖
1.删掉无用注释<br />2.注意哪些永不失败的测试用例<br />3.平台偏见


<a name="T7dsH"></a>
### 可测的设计
**应当容易和快速地为一段代码编写单元测试**

<a name="rOyVx"></a>
#### 模块化设计
1.SOLID:单一职责、开闭原则、里式替换原则、接口隔离原则、依赖反转。<br />2.以测试驱动出模块化设计

<a name="B52uu"></a>
#### 可测性问题
遇到的障碍主要集中在：访问受限、无法替换实现的某些部分<br />1.无法实例化某个类：可见性或者静态初始化代码块中对某些坏境变量的依赖<br />2.无法调用某个方法：private等<br />3.无法观察到输出<br />4.无法替换某个协作者<br />5.无法覆盖某个方法

<a name="WDkVW"></a>
#### 可测的设计指南
1.尽量避免直接测试private方法，通过public来测试它们<br />2.很少有程序需要final方法，final的目的是为了确保子类不会覆盖它，在安全上比较难避免因为有反射或字节码，而在性能上并不会带来多大的影响，但却影响可测试性。<br />这点我觉得需要看情况，用final其实是对后来维护者的一种不信任，在性能上的差异并不会决定我是否使用它。<br />3.避免static方法？？？小心new？？？这两点我不是很赞同<br />4.避免在构造函数中包含逻辑--这个是基本的编码规范<br />5.避免单例？？？在适当的情况下使用无妨，但是很多bug就是对单例的错误使用造成的。遇到过不少。<br />6.组合由于继承<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1587100905544-e203781f-131e-4e9c-9493-5f45badf0326.png#align=left&display=inline&height=234&margin=%5Bobject%20Object%5D&name=image.png&originHeight=234&originWidth=516&size=141267&status=done&style=none&width=516)<br />7.封装外部库

<a name="1XKDx"></a>
### 用其他JVM语言来编写测试
需要学习下Groovy,并简单了解下Spock/TestNG相关的测试框架

<a name="ed731"></a>
### Junit

<a name="lsa7Q"></a>
### JMockit
![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1587180859579-1dc008ee-0875-46f0-81e6-0c5843cd5b1e.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=image.png&originHeight=227&originWidth=1553&size=250496&status=done&style=none&width=1553)<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1587180839371-df81fdcb-add7-4798-9f50-950298562744.png#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&name=image.png&originHeight=436&originWidth=1343&size=189686&status=done&style=none&width=1343)<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/471305/1587180961635-c29000dd-47fc-4c5c-843f-bb75204d178b.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&name=image.png&originHeight=117&originWidth=975&size=52301&status=done&style=none&width=975)


@Injectable 也是告诉 JMockit生成一个Mocked对象，但@Injectable只是针对其修饰的实例，而@Mocked是针对其修饰类的所有实例。此外，@Injectable对类的静态方法，构造函数没有影响
