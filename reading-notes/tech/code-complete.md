如果把这本书比喻成一只狗，那么它将用鼻子轻擦创建活动，尾巴扫过设计与测试，而同时向其它开发活动汪汪叫。

## 欢迎进入 Software Construction 世界

> 在正规性与随意性之间达到平衡是非常困难的。


![01-01](/statistic/img/reading/code-complete/01-01.png)

> Software Construction 主要包括编码和调试
> - Software Construction 是总体设计和系统测试之间承上启下的工作。

> - Software Construction 是唯一一项必不可少的工作，是开发软件的重要组成部分，是软件开发的核心工作。
> - 源代码，往往是软件的唯一精确描述，因为它总是最新的
> - 把主要精力集中于 Software Construction，可以极大地提高程序员的生产效率


<br>

## 利用隐喻对编程进行更深刻的理解

> 重大发现往往是从类比中产生的。通过把一个你所陌生的事物与你所熟知的事物比较，你会对它有进一步的认识，从而形成你对它的独到的深刻理解这种隐喻方法被称之为“模型化”。在科学发展史上，充满了利用类比而产生的发现。

> 科学史并不是由一系列从“错误”模型到“正确”模型开关组成的，而是逐渐由“坏的”模型变为“较好”的模型，从包含面较窄到包含面较宽，从覆盖领域较少到覆盖领域较多。


> 启发是一种帮助你寻求答案的技术。它的结果往往和运气有关，因为它只告诉你如何去找，而并未告诉你应该找到些什么。


> 如果有一套指令告诉你该如何解决程序中的问题，这当然会使编程变得很容易，而且结果也可以预测了。但是编程科学目前还没有那样发达，也许永远也不会。**编程中最富于挑战性的问题便是将问题概念化**，编程中许多错误往往都是概念性错误，因为每个程序在概念上都是独特的，所以创立一套可以指导每一个问题的规则是非常困难，甚至是不可能的。这样，从总体上知道该如何解决问题，便几乎和知道某一特定问题的答案一样重要了。

**note**: 这也是为什么我认为一个优秀的工程师并不总是那些仅仅技术厉害的程序员的原因，确定性总是能通过更多的人力去解决的，而不决定性往往决定事情的成败以及问题能否被顺利解决。


> 几乎有 50 ％的软件开发工作量是在软件最初发行之后才进行的（Lientz 和 Swanson，1980）。

> 一个优秀的工匠知道用什么样的工具干哪一样工作，而且知道该如何使用它们。程序员也是如此，关于编程你理解得越深入，你的工具箱里的工具也就越多，何时何地该如何运用它们的知识也就越多。

> 不要把最新的“面向对象设计技术”当作上帝赐予的法宝，它不过是一件在某些场合下有用，而在某些场合下又无用的技术。如果你拥有的唯一工具就是一把锤子，那么你就会把整个世界都当作一个钉子。

**note**: 这也提醒我们不要写入原教旨主义里，事情能得到推进在我看来是更重要的。


## Software Construction 的先决条件

###  先决条件重要性 
> A common denominator of programmers who build high-quality software is their use of high-quality practices. Such practices emphasize quality at the beginning, middle, and end of a project.

> 如果你只在一个计划即将结束时强调质量，那你注重的只是测试。当某些人一谈起软件质量时，他们首先想到的便是测试。然而，事实上测试只是全部质量控制策略的一部分。而且并不是最重要的部分。测试既不能消除在正确方向上的错误工作，也不能消除在错误方向上的正确工作的错误，这种错误必须在测试开始之前就清除掉，甚至在创建工作开始之前就要努力清除掉它们。

> The overarching goal of preparation is risk reduction: a good project planner clears major risks out of the way as early as possible so that the bulk of the project can proceed as smoothly as possible. By far the most common project risks in software development are poor requirements and poor project planning, thus preparation tends to focus on improving requirements and project plans


> - 一些程序员并不作准备工作，因为他们抵制不了立刻开始进行编码工作的渴望
> - 程序员不重视准备工作的另一个原因是管理人员往往不理解那些在创建先决条件上花费时
间的程序员

> 你可以另找一份工作。优秀的程序员是非常短缺的。可以找到更好的工作，干吗非要呆在一个很不开明的程序店里徒损生命呢？


### 需求分析先决条件 

> 充分进行需求分析是一个项目成功的关键，很可能比使用有效的创建技术还重要



在创建阶段如何对付需求变化 :
- 让每个人都知道由于变化需求所付出的代价
- 建立一套更改控制过程
- 用开发的方法来容纳变动
- 放弃项目


### 结构设计先决条件 
> 结构设计应该清晰地描述系统应付变动的策略。结构设计应该表明：设计中已经考虑到了可能的功能增强变动，而且，应该使最可能的变动同时也是最容易实现的变动。

> 数据守恒定律：每一个进入的数据都应该出去，或者与其它数据一道出去，如果它不出去，那它就没有必要进来。

**note**: 这个说法倒是第一次进入我的视野


**如果想开发一个高质量的软件，必须自始至终重视质量问题。在开始阶段强调质量往往比在最后强调质量更为有效。**

**note**: 必要的架构设计和设计评审、讨论是必要的

<br>

## 建立子程序的步骤

> 从程序设计语言（PDL）到编码的转换过程，几乎没有哪些程序员充分利用了这一过程所带来的方便。

**note**: 可能因为工作经历接触到的软件系统没有足够复杂，并没有做过这一步的设计。


## 高质量子程序特点

> 除了计算机本身之外，子程序可以说是计算机科学最重大的发明。子程序使得程序非常好读而且也非常容易理解，编程语言中的任何特性都不能和这一点相比。

> 子程序也是节省空间和提高性能的最好手段

### 生成子程序的原因

- 降低复杂性 使用子程序的最首要原因是为了降低程序的复杂性，可以使用子程序来隐含信息，从而使你不必再考虑这些信息。
- 限制了改动带来的影响。要把最可能改动的区域设计成最容易改动的区域。
- 隐含顺序。
- 改进性能。
- 进行集中控制
- 隐含数据结构
- 隐含全局变量
- 隐含指针操作
- 提高部分代码的可读性
- 提高可移植性
- 简化复杂的布尔测试
- 是出于模块化的考虑吗？绝不是

**note:** 最后这一点有点出乎我的意料...


### 子程序名称恰当 

- 对于过程的名字，可以用一个较强的动词带目标的形式
- 对于函数名字，可以使用返回值的描述
- 避免无意义或者模棱两可的动词
- 名字的长度要符合需要。研究表明，变量名称的最佳长度是 9 到 15 个字母，子程序往往比变量要复杂，因而其名字也要长些

###  强内聚性 

强调强相关性的目的是，每一个子程序只需作好一项工作，而不必过分考虑其它任务。

**可取的内聚性**
- 功能内聚性。功能内聚性是最强也是最好的一种内聚，当程序执行一项并且仅仅是一项工作时，就是这种内聚性。
- 顺序内聚性
- 通讯内聚性
- 临时内聚性

**不可取的内聚性**

如果一个子程序具有不良的内聚性，那最好重新创建一个较好的子程序，而
不要去试图修补它。


### 松散耦合性

**可接受的数据结构耦合的例子**：一个程序向另一个子程序传递变量 EmpRec，EmpRec 是一个结构化的变量，包括姓名、住址、生日等等五个方面的数据，而被调用的子程序则全部使用这五个域。

**不可取的数据结构耦合举例**：一个程序向另一个子程序传递同样的变量 EmpRec，但是，如果被调用的子程序只使用其中两个域，比如电话号码和生日。这虽然还是数据结构耦合，但却不是个很好的应用，如果把生日和电话号码作为简单变量来传递的话，将使联系更加灵活，而且会使它们之间的两个特定域真正联系的可见性更好。

**有问题的数据结构耦合的例子**：一个程序向另一个子程序传递变量 OfficeRec。OfficeRec 有 27 个域，而被调用的子程序使用其中 16 个，这也是数据结构耦合，但是，它是一个好的数据结构耦合吗？决不是。传递 OfficeRec 使得联系是大规模的，这个事实非常明显，而传递 16 个单独参数，则又再次非常拙劣地表明了这一点，如果被调用子程序仅使用其中的 6 到 7 个域，那么单个地传递它们是个好主意。这种情况下，可以进一步对 OfficeRec 进行结构化，以使得在被调用程序中用得到的 16 个域包含在一个或两个亚结构中。

![松耦合](/statistic/img/reading/code-complete/05-04.jpeg)

### 子程序的长度
![子程序长度](/statistic/img/reading/code-complete/05-05.jpeg)


### 防御性编程
![防御性编程](/statistic/img/reading/code-complete/05-06.jpeg)


- 使用断言
- 输入垃圾不一定输出垃圾
- 异常情况处理
- 预计改动
- 检查函数返回值


**对防错性编程提高警惕**

> 过多的防错性编程会带来它自身的问题，如果你对每一种可以察觉的参数传递，在每一个可以察觉的地方都进行检查，那么程序将变得臃肿而笨拙。考虑好需要在哪里预防错误，然后再使用防错性编程。

note: 假设我们有一个供外部调用的 `methodA`, 其内部有两个私有的 `methodB` 和 `methodC`，假设这两个私有函数的入参和共有函数是相同的，我们有必要在 `methodA` 的入参做好防御性编程，而在 `methodB` 和 `methodC` 做防御性编程的必要性却没那么高。


### 子程序参数

> 子程序间的接口往往是一个程序中最容易出错的部分

- 确保实际参数与形式参数匹配。（主要指变量类型）
- 按照输入一修改一输出的顺序排列参数
![列参数](/statistic/img/reading/code-complete/05-07.jpeg)
- 如果几个子程序今使用了相似的参数，应按照不变的顺序排到这些参数。
- 使用所有的参数 , 不使用就删掉它
- 把状态和“错误”变量放在最后
- 不要把子程序中的参教当作工作变量。如果你需要为全局计算的最后把最终值赋给全局变量，而不要把中间值赋给它。

![说明](/statistic/img/reading/code-complete/05-08.jpeg)

- 应该把一个子程序中的参数个数限制在 7 个左右


### 使用函数 

- 什么时侯使用函数，什么时侯使用过程
- 由函数带来的独特危险。使用函数产生了可能不恰当值的危险，这常常是函数有几条可能的路径，而其中一条路径又没有返回一个值时产生的。在建立一个函数时，应该在心中执行每一条路径，以确认函数在所有情况下都可以返回一个值。

note: 不要陷入教条主义