如果把这本书比喻成一只狗，那么它将用鼻子轻擦创建活动，尾巴扫过设计与测试，而同时向其它开发活动汪汪叫。

## 欢迎进入Software Construction世界

> 在正规性与随意性之间达到平衡是非常困难的。


![01-01](/statistic/img/reading/code-complete/01-01.png)

> Software Construction主要包括编码和调试
> - Software Construction 是总体设计和系统测试之间承上启下的工作。

> - Software Construction是唯一一项必不可少的工作，是开发软件的重要组成部分，是软件开发的核心工作。
> - 源代码，往往是软件的唯一精确描述，因为它总是最新的
> - 把主要精力集中于Software Construction，可以极大地提高程序员的生产效率


<br>

## 利用隐喻对编程进行更深刻的理解

> 重大发现往往是从类比中产生的。通过把一个你所陌生的事物与你所熟知的事物比较，你会对它有进一步的认识，从而形成你对它的独到的深刻理解这种隐喻方法被称之为“模型化”。在科学发展史上，充满了利用类比而产生的发现。

> 科学史并不是由一系列从“错误”模型到“正确”模型开关组成的，而是逐渐由“坏的”模型变为“较好”的模型，从包含面较窄到包含面较宽，从覆盖领域较少到覆盖领域较多。


> 启发是一种帮助你寻求答案的技术。它的结果往往和运气有关，因为它只告诉你如何去找，而并未告诉你应该找到些什么。


> 如果有一套指令告诉你该如何解决程序中的问题，这当然会使编程变得很容易，而且结果也可以预测了。但是编程科学目前还没有那样发达，也许永远也不会。**编程中最富于挑战性的问题便是将问题概念化**，编程中许多错误往往都是概念性错误，因为每个程序在概念上都是独特的，所以创立一套可以指导每一个问题的规则是非常困难，甚至是不可能的。这样，从总体上知道该如何解决问题，便几乎和知道某一特定问题的答案一样重要了。

**note**:这也是为什么我认为一个优秀的工程师并不总是那些仅仅技术厉害的程序员的原因，确定性总是能通过更多的人力去解决的，而不决定性往往决定事情的成败以及问题能否被顺利解决。


> 几乎有50％的软件开发工作量是在软件最初发行之后才进行的（Lientz和Swanson，1980）。

> 一个优秀的工匠知道用什么样的工具干哪一样工作，而且知道该如何使用它们。程序员也是如此，关于编程你理解得越深入，你的工具箱里的工具也就越多，何时何地该如何运用它们的知识也就越多。

> 不要把最新的“面向对象设计技术”当作上帝赐予的法宝，它不过是一件在某些场合下有用，而在某些场合下又无用的技术。如果你拥有的唯一工具就是一把锤子，那么你就会把整个世界都当作一个钉子。

**note**:这也提醒我们不要写入原教旨主义里，事情能得到推进在我看来是更重要的。


## Software Construction的先决条件

###  先决条件重要性 
> A common denominator of programmers who build high-quality software is their use of high-quality practices. Such practices emphasize quality at the beginning, middle, and end of a project.

> 如果你只在一个计划即将结束时强调质量，那你注重的只是测试。当某些人一谈起软件质量时，他们首先想到的便是测试。然而，事实上测试只是全部质量控制策略的一部分。而且并不是最重要的部分。测试既不能消除在正确方向上的错误工作，也不能消除在错误方向上的正确工作的错误，这种错误必须在测试开始之前就清除掉，甚至在创建工作开始之前就要努力清除掉它们。

> The overarching goal of preparation is risk reduction: a good project planner clears major risks out of the way as early as possible so that the bulk of the project can proceed as smoothly as possible. By far the most common project risks in software development are poor requirements and poor project planning, thus preparation tends to focus on improving requirements and project plans


> - 一些程序员并不作准备工作，因为他们抵制不了立刻开始进行编码工作的渴望
> - 程序员不重视准备工作的另一个原因是管理人员往往不理解那些在创建先决条件上花费时
间的程序员

> 你可以另找一份工作。优秀的程序员是非常短缺的。可以找到更好的工作，干吗非要呆在一个很不开明的程序店里徒损生命呢？


### 需求分析先决条件 

> 充分进行需求分析是一个项目成功的关键，很可能比使用有效的创建技术还重要



在创建阶段如何对付需求变化:
- 让每个人都知道由于变化需求所付出的代价
- 建立一套更改控制过程
- 用开发的方法来容纳变动
- 放弃项目


### 结构设计先决条件 
> 结构设计应该清晰地描述系统应付变动的策略。结构设计应该表明：设计中已经考虑到了可能的功能增强变动，而且，应该使最可能的变动同时也是最容易实现的变动。

> 数据守恒定律：每一个进入的数据都应该出去，或者与其它数据一道出去，如果它不出去，那它就没有必要进来。

**note**: 这个说法倒是第一次进入我的视野


**如果想开发一个高质量的软件，必须自始至终重视质量问题。在开始阶段强调质量往往比在最后强调质量更为有效。**

**note**:必要的架构设计和设计评审、讨论是必要的

<br>

## 建立子程序的步骤

> 从程序设计语言（PDL）到编码的转换过程，几乎没有哪些程序员充分利用了这一过程所带来的方便。

**note**:可能因为工作经历接触到的软件系统没有足够复杂，并没有做过这一步的设计。


## 高质量子程序特点

> 除了计算机本身之外，子程序可以说是计算机科学最重大的发明。子程序使得程序非常好读而且也非常容易理解，编程语言中的任何特性都不能和这一点相比。

> 子程序也是节省空间和提高性能的最好手段

### 生成子程序的原因

- 降低复杂性 使用子程序的最首要原因是为了降低程序的复杂性，可以使用子程序来隐含信息，从而使你不必再考虑这些信息。
- 限制了改动带来的影响。要把最可能改动的区域设计成最容易改动的区域。
- 隐含顺序。
- 改进性能。
- 进行集中控制
- 隐含数据结构
- 隐含全局变量
- 隐含指针操作
- 提高部分代码的可读性
- 提高可移植性
- 简化复杂的布尔测试
- 是出于模块化的考虑吗？绝不是

**note:** 最后这一点有点出乎我的意料...


### 子程序名称恰当 

- 对于过程的名字，可以用一个较强的动词带目标的形式
- 对于函数名字，可以使用返回值的描述
- 避免无意义或者模棱两可的动词
- 名字的长度要符合需要。研究表明，变量名称的最佳长度是 9 到 15 个字母，子程序往往比变量要复杂，因而其名字也要长些

###  强内聚性 

强调强相关性的目的是，每一个子程序只需作好一项工作，而不必过分考虑其它任务。

**可取的内聚性**
- 功能内聚性。功能内聚性是最强也是最好的一种内聚，当程序执行一项并且仅仅是一项工作时，就是这种内聚性。
- 顺序内聚性
- 通讯内聚性
- 临时内聚性

**不可取的内聚性**

如果一个子程序具有不良的内聚性，那最好重新创建一个较好的子程序，而
不要去试图修补它。


### 松散耦合性
